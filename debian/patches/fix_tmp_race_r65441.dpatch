#! /bin/sh /usr/share/dpatch/dpatch-run
## fix_tmp_race_r65441.dpatch by Mirco Bauer <meebey@meebey.net>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad mono-1.1.17.1~/mcs/class/System/System.CodeDom.Compiler/TempFileCollection.cs mono-1.1.17.1/mcs/class/System/System.CodeDom.Compiler/TempFileCollection.cs
--- mono-1.1.17.1~/mcs/class/System/System.CodeDom.Compiler/TempFileCollection.cs	2006-10-03 15:17:50.000000000 +0200
+++ mono-1.1.17.1/mcs/class/System/System.CodeDom.Compiler/TempFileCollection.cs	2006-10-03 15:18:17.000000000 +0200
@@ -31,6 +31,7 @@
 using System.IO;
 using System.Security;
 using System.Security.Permissions;
+using System.Runtime.InteropServices;
 
 namespace System.CodeDom.Compiler {
 
@@ -45,6 +46,7 @@
 		bool keepfiles;
 		string basepath;
 		Random rnd;
+		string ownTempDir;
 		
 		public TempFileCollection ()
 			: this (String.Empty, false)
@@ -67,16 +69,15 @@
 		{
 			get {
 				if(basepath==null) {
-					// note: this property *cannot* change TempDir property
-					string temp = tempdir;
-					if (temp.Length == 0) {
-						// this call ensure the Environment permissions check
-						temp = Path.GetTempPath ();
-					}
-
+				
 					if (rnd == null)
 						rnd = new Random ();
 
+					// note: this property *cannot* change TempDir property
+					string temp = tempdir;
+					if (temp.Length == 0)
+						temp = GetOwnTempDir ();
+
 					// Create a temporary file at the target directory. This ensures
 					// that the generated file name is unique.
 					FileStream f = null;
@@ -111,6 +112,32 @@
 				return(basepath);
 			}
 		}
+		
+		string GetOwnTempDir ()
+		{
+			if (ownTempDir != null)
+				return ownTempDir;
+
+			// this call ensure the Environment permissions check
+			string basedir = Path.GetTempPath ();
+			
+			// Create a subdirectory with the correct user permissions
+			int res = -1;
+			do {
+				int num = rnd.Next ();
+				num++;
+				ownTempDir = Path.Combine (basedir, num.ToString("x"));
+				if (Directory.Exists (ownTempDir))
+					continue;
+				res = mkdir (ownTempDir, 0x1c0);
+				if (res != 0) {
+					if (!Directory.Exists (ownTempDir))
+						throw new IOException ();
+					// Somebody already created the dir, keep trying
+				}
+			} while (res != 0);
+			return ownTempDir;
+		}
 
 		int ICollection.Count {
 			get {
@@ -190,18 +217,25 @@
 		
 		public void Delete()
 		{
-			string[] filenames=new string[filehash.Count];
-			filehash.Keys.CopyTo(filenames, 0);
+			bool allDeleted = true;
+			string[] filenames = new string[filehash.Count];
+			filehash.Keys.CopyTo (filenames, 0);
 
 			foreach(string file in filenames) {
 				if((bool)filehash[file]==false) {
 					File.Delete(file);
 					filehash.Remove(file);
-				}
+				} else
+					allDeleted = false;
 			}
 			if (basepath != null) {
 				string tmpFile = basepath + ".tmp";
 				File.Delete (tmpFile);
+				basepath = null;
+			}
+			if (allDeleted && ownTempDir != null) {
+				Directory.Delete (ownTempDir, true);
+				ownTempDir = null;
 			}
 		}
 
@@ -228,5 +262,6 @@
 			Dispose(false);
 		}
 		
+		[DllImport ("libc")] private static extern int mkdir (string olpath, uint mode);
 	}
 }
